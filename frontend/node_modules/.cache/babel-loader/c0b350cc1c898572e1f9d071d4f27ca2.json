{"ast":null,"code":"export let HTTPMethod;\n(function (HTTPMethod) {\n  HTTPMethod[\"head\"] = \"HEAD\";\n  HTTPMethod[\"get\"] = \"GET\";\n  HTTPMethod[\"put\"] = \"PUT\";\n  HTTPMethod[\"patch\"] = \"PATCH\";\n  HTTPMethod[\"post\"] = \"POST\";\n  HTTPMethod[\"delete\"] = \"DELETE\";\n})(HTTPMethod || (HTTPMethod = {}));\nexport class APIError {\n  constructor(code, message, details) {\n    this.code = void 0;\n    this.message = void 0;\n    this.details = void 0;\n    this.code = code;\n    this.message = message;\n    this.details = details;\n  }\n}\nexport class Request {\n  constructor(method, path) {\n    let parser = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : data => data;\n    this.method = void 0;\n    this.path = void 0;\n    this.parser = void 0;\n    this.method = method;\n    this.path = path;\n    this.parser = parser;\n  }\n}\nexport class Response {\n  constructor(data, error) {\n    this.data = void 0;\n    this.error = void 0;\n    this.data = data;\n    this.error = error;\n  }\n}\nexport class Requestable {\n  constructor(service, request) {\n    this.service = void 0;\n    this.request = void 0;\n    this.headers = void 0;\n    this.body = void 0;\n    this.query = void 0;\n    this.service = service;\n    this.request = request;\n  }\n  withHeaders(headers) {\n    this.headers = {\n      ...this.headers,\n      ...headers\n    };\n    return this;\n  }\n  withBody(body) {\n    this.body = body;\n    return this;\n  }\n  withQuery(params) {\n    this.query = {\n      ...this.query,\n      ...params\n    };\n    return this;\n  }\n  async call() {\n    let parseFunc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : v => v;\n    let globalHeaders = {};\n    if (this.service.headers) {\n      globalHeaders = {\n        ...globalHeaders,\n        ...(await this.service.headers())\n      };\n    }\n    if (this.body) {\n      globalHeaders['Content-Type'] = 'application/json';\n    }\n    let url = new URL(`${this.service.baseUrl}/${this.request.path}`);\n    const q = this.query;\n    if (q) {\n      Object.keys(q).forEach(key => url.searchParams.append(key, q[key]));\n    }\n    const response = await fetch(url.href, {\n      method: this.request.method,\n      headers: {\n        ...globalHeaders,\n        ...this.headers\n      },\n      body: this.body && JSON.stringify(this.body)\n    });\n    if (response.status >= 400) {\n      const returnError = new APIError(response.status, response.statusText);\n      returnError.details = await response.json().catch(ex => null);\n      throw returnError;\n    } else if (response.status === 204) {\n      return parseFunc(undefined);\n    }\n    try {\n      const json = await response.json();\n      return json;\n    } catch (ex) {\n      console.error(ex);\n      throw ex;\n    }\n  }\n  async rawCall() {\n    let globalHeaders = {};\n    if (this.service.headers) {\n      globalHeaders = {\n        ...globalHeaders,\n        ...(await this.service.headers())\n      };\n    }\n    if (this.body) {\n      globalHeaders['Content-Type'] = 'application/json';\n    }\n    let url = new URL(`${this.service.baseUrl}/${this.request.path}`);\n    const q = this.query;\n    if (q) {\n      Object.keys(q).forEach(key => url.searchParams.append(key, q[key]));\n    }\n    const response = await fetch(url.href, {\n      method: this.request.method,\n      headers: {\n        ...globalHeaders,\n        ...this.headers\n      },\n      body: this.body && JSON.stringify(this.body)\n    });\n    if (response.status >= 400) {\n      const returnError = new APIError(response.status, response.statusText);\n      returnError.details = await response.json().catch(ex => null);\n      throw returnError;\n    }\n    return response;\n  }\n}\nexport function request(service, request) {\n  return new Requestable(service, request);\n}","map":{"version":3,"names":["HTTPMethod","APIError","constructor","code","message","details","Request","method","path","parser","data","Response","error","Requestable","service","request","headers","body","query","withHeaders","withBody","withQuery","params","call","parseFunc","v","globalHeaders","url","URL","baseUrl","q","Object","keys","forEach","key","searchParams","append","response","fetch","href","JSON","stringify","status","returnError","statusText","json","catch","ex","undefined","console","rawCall"],"sources":["/Users/adamberri/Downloads/cd-fs-take-home-problem-main/frontend/src/utils/_abstract.ts"],"sourcesContent":["export enum HTTPMethod {\n    head = \"HEAD\",\n    get = \"GET\",\n    put = \"PUT\",\n    patch = \"PATCH\",\n    post = \"POST\",\n    delete = \"DELETE\"\n}\n\nexport interface Headers { [s: string]: string; }\n\nexport class APIError {\n    code: number\n    message: string\n    details?: object | null\n\n    constructor(code: number, message: string, details?: object | null) {\n        this.code = code\n        this.message = message\n        this.details = details\n    }\n}\n\nexport class Request<T> {\n    method: HTTPMethod\n    path: string\n    parser: (data: any) => T\n\n    constructor(method: HTTPMethod, path: string, parser: (data: any) => T = (data) => (data as T)) {\n        this.method = method\n        this.path = path\n        this.parser = parser\n    }\n}\n\nexport class Response<T> {\n    data?: T\n    error?: Error\n\n    constructor(data?: T, error?: Error) {\n        this.data = data\n        this.error = error\n    }\n}\n\nexport interface Service {\n\n    // Represents the baseUrl for the service\n    baseUrl: string\n    \n    /// Any specific headers for this service\n    headers?: () => Promise<Headers>\n}\n\nexport class Requestable<T> {\n    service: Service\n    request: Request<T>\n    headers?: Headers\n    body?: any\n    query?: Record<string, string>\n\n    constructor(service: Service, request: Request<T>) {\n        this.service = service\n        this.request = request\n    }\n    \n    withHeaders(headers: Headers): Requestable<T> {\n        this.headers = {\n            ...this.headers,\n            ...headers\n        }\n        return this\n    }\n\n    withBody(body: any): Requestable<T> {\n        this.body = body\n        return this\n    }\n\n    withQuery(params: object): Requestable<T> {\n        this.query = {\n            ...this.query,\n            ...params\n        }\n        return this\n    }\n\n    async call(parseFunc: (v: any) => T = (v) => v as T): Promise<T> {\n\n        let globalHeaders: { [key: string]: string }  = {}\n\n        if (this.service.headers) {\n            globalHeaders = {\n                ...globalHeaders,\n                ...(await this.service.headers())\n            }\n        }\n\n        if (this.body) {\n            globalHeaders['Content-Type'] = 'application/json'\n        }\n\n        let url = new URL(`${this.service.baseUrl}/${this.request.path}`)\n        \n        const q = this.query\n        if (q) {\n            Object.keys(q).forEach(key => url.searchParams.append(key, q[key]))\n        }\n        \n        const response = await fetch(url.href, {\n            method: this.request.method,\n            headers: {\n                ...globalHeaders,\n                ...this.headers\n            },\n            body: this.body && JSON.stringify(this.body),\n        })\n        \n        if (response.status >= 400) {\n            const returnError = new APIError(response.status, response.statusText)\n            returnError.details = await response.json().catch(ex => null)\n\n            throw returnError\n        }\n        else if (response.status === 204) {\n            return parseFunc(undefined);\n        }\n        \n        try {\n            const json = await response.json()\n            return json\n        }\n        catch (ex) {\n            \n            console.error(ex)\n            throw ex\n        }\n    }\n\n    async rawCall(): Promise<globalThis.Response> {\n\n        let globalHeaders: { [key: string]: string }  = {}\n\n        if (this.service.headers) {\n            globalHeaders = {\n                ...globalHeaders,\n                ...(await this.service.headers())\n            }\n        }\n\n        if (this.body) {\n            globalHeaders['Content-Type'] = 'application/json'\n        }\n\n        let url = new URL(`${this.service.baseUrl}/${this.request.path}`)\n        const q = this.query\n        if (q) {\n            Object.keys(q).forEach(key => url.searchParams.append(key, q[key]))\n        }\n        \n        const response = await fetch(url.href, {\n            method: this.request.method,\n            headers: {\n                ...globalHeaders,\n                ...this.headers\n            },\n            body: this.body && JSON.stringify(this.body),\n        })\n        \n        if (response.status >= 400) {\n            const returnError = new APIError(response.status, response.statusText)\n            returnError.details = await response.json().catch(ex => null)\n\n            throw returnError\n        }\n        \n        return response\n    }\n}\n\nexport function request<T>(service: Service, request: Request<T>): Requestable<T> {\n    return new Requestable<T>(service, request)\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}